---
title: "STAT 428 Group Written Report"
date: "Due May 3, 2019"
output:
  html_document:
    theme: readable
    toc: yes
  pdf_document:
    toc: yes
---

```{r global_options, include=FALSE}
library(knitr)
knitr::opts_chunk$set(fig.pos = '!h')
```

*Title:* Tournament Bracket Simulation and Analysis  
*Group Number:* 3  
*Members:* Eric Auster (eauste2), Philip Dohm (pdohm2), Yuchen Li (li215), Ziqin Xiong (zxiong8), Jeffrey Chao (jschao2)  
*Leader:* Eric Auster   

-----

## Abstract



-----

## Introduction

Anticipating the winner of a tournament such as in the NBA or MLB is part of what makes watching these sports entertaining.  These tournaments often utilize a “bracket” structure, which is a tree diagram that represents the series of games played.  For example, in the 8 team single elimination bracket seen in Figure 1, the bracket proceeds from left to right, in which Team A plays Team B, Team C plays Team D, and so on.  The winning team of each match is denoted by marking the team name on the parent branch.  Respective parent branches then play each other until we reach the root of the tree, which will denote the winner of the tournament.  

Most major North American professional sports leagues hold a bracket-style tournament at the end of their season, known as a “playoff”.  Notably, the NCAA holds a basketball tournament with 68 college teams, and traditionally, fans will predict brackets outcomes in an event known as “March Madness”.  

```{r, echo=FALSE, out.width = "50%", fig.pos="h", fig.align="center", fig.cap="Figure 1"}
include_graphics("Figure 1.png")
```

Our problem of interest consists of discovering the most likely bracket outcome in a tournament given data on head-to-head matchups between teams.  The outcome of this type of analysis is potentially important to coaches, viewers, and the team members themselves.  It can be especially important to sports bettors, who traditionally rely on human intuition rather than data-driven techniques to make their bets.  According to sports journalist and bracketology expert Richard Sandomir, studying bracket prediction can have relevance beyond sports, such as in pop culture, nature, and history.  

-----

## Methods

### Tournament Simulation

The first step of simulating a tournament is providing each team with a seed. A seed defines where in the bracket each team will be placed, and usually stronger teams get lower seed numbers while weaker teams get higher seed numbers. The results of the tournament can be greatly affected by how the tournament is seeded, and because of this, we have created three different kinds of seeding functions that are defined in the [Appendix] at section [Seeding Functions]. The most notable seeding function is `tournament_seeding` which generates a bracket layout that is quite common in traditional real world tournaments where the structure is set up in such a way that seed 1 and seed 2 are most likely to be finalists in the last tournament matchup.  

We simulate tournament brackets using Monte Carlo simulation. Given the same set of teams, we simulate tournament results thousands of times to get data on tournament winners and how far on average each team proceeds. Monte Carlo inference works well for this purpose since early round results have a snowball effect on later round results. For example, in Figure 2, we see an example tournament run. If we imagine that Team B beat Team A in round 1 instead, the head-to-head win probability would change for the first match of round 2. Then the probability of D advancing to round 3 and eventually winning would change as well.

```{r, echo=FALSE, out.width = "50%", fig.pos="h", fig.align="center", fig.cap="Figure 2"}
include_graphics("Figure 2.png")
```

The algorithm for simulating a single bracketed tournament can be seen in the appendix under [Simulation Functions], and works roughly as follows:  

1. Take in a tournament bracket in the form of a vector of teams, and a square probability matrix $M$ where $M_{ij}$ is the probability of team $i$ beating team $j$.  
2. Simulate each individual game in round 1, returning a new bracket that represents the teams going into round 2.  Then simulate round 2, returning a new bracket that represents teams going into round 3, and so on, for $log_2(n)$ rounds where $n$ is the number of teams.  
3. Return the winner of the tournament and a vector of integers representing the number of wins each team had.  

We then get our Monte Carlo simulation results in the form of a 2-D array by using `replicate` on our tournament simulation function.  

-----

## Results



-----

## Discussion



-----

## Appendix

### Data Generation Functions

```{r}
#' Generates team powers based on the normal distribution.
#' @author Yuchen Li
#'
#' @param n is the number of teams.
#' @param mean is the mean of the normal distribution.
#' @param sd is the standard deviation of the normal distribution.
#'
#' @return a vector of team powers, sorted in decreasing order.
#'
genNormalPowers <- function(n, mean=0, sd=1) {
    powers <- rnorm(n, mean, sd)
    return(sort(abs(powers), decreasing=TRUE))
}

#' Performs the Accept-Reject method.
#' @author Yuchen Li
#' @references Yuchen Li (li215), HW2, Exercise 4
#'
#' @param nsim is the number of simulations.
#' @param f is the target distribution.
#' @param min is the minimum value in the domain of f.
#' @param max is the maximum value in the domain of f.
#' @param M >= sup{f(x)}
#' 
#' @return a vector of random variates sampled from f using the
#' Accept-Reject method with Unif(min, max) as the reference distribution.
#'
acceptReject <- function(nsim, f, min, max, M) {
    k1 = 0             # counter for accepted samples
    j1 = 0             # number of iterations required to get desired sample size
    y1 = numeric(nsim) # storing the sample
    while(k1 < nsim){
        u = runif(1)
        x = runif(1, min, max)  # random variate from reference distribution
        g1 = 1
        if (u < f(x) / M / g1) {
            # condition of accepting x in our sample
            k1 = k1 + 1
            y1[k1] = x
        }
        j1 = j1 + 1
    }
    return(sort(y1, decreasing=TRUE))
}

#' Performs the Inverse CDF method.
#' @author Yuchen Li
#' 
#' @param n is the number of simulations.
#' @param inv_cdf is the inverse CDF function for f.
#' 
#' @return a vector of random variates sampled from PDF f using the
#' Inverse CDF method.
#' 
inverseCDF <- function(n, inv_cdf) {
    u = runif(n)
    y = numeric(n)
    for (i in 1:n) {
        y[i] = inv_cdf(u[i])
    }
    return(sort(y, decreasing=TRUE))
}

#' Generates cross team winning probabilities.
#' @author Yuchen Li
#' 
#' @param powers is the team powers.
#' 
#' @return an n x n matrix M where M_{ij} is the probability of team-i beating team-j
genCrossTeamWinningProbabilities <- function(powers) {
    n = length(powers)
    probs = matrix(nrow=n, ncol=n)
    for (i in 1:n) {
        for (j in 1:n) {
            probs[i,j] = powers[i] / (powers[i] + powers[j])
        }
    }
    return(probs)
}
```

### Seeding Functions

```{r}
#' Creates a traditional tournament style seeding arrangement. 
#' @author Eric Auster
#'
#' @param size is the number of seeds to generate. This needs
#' to be a power of two.
#'
#' @return a vector containing the seeds.
#'
tournament_seeding = function(size) {
    
    #' Generates the next round of seeding based off the passed in round.
    #'
    #' @param seeds is the previous round of seeding to generate for.
    #'
    nextRound = function(seeds) {
        
        # Next round has twice the size
        nextSize = length(seeds) * 2
        out = numeric(nextSize)
        idx = 1
        
        # Make sure to match up best seed with worst
        for (seed in seeds) {
            out[idx] = seed
            out[idx + 1] = (nextSize + 1) - seed
            idx = idx + 2
        }
        
        return(out)
    }
    
    # Stop if not a power of two
    if (sum(as.numeric(intToBits(size))) != 1) {
        stop("Size must be a power of two")
    }
    
    # Special case when size is 2
    if (size == 2) {
        return(c(1, 2))
    }
    
    # Calculate number of rounds
    rounds = log2(size) - 1
    
    # Start with first two seeds
    seeds = c(1, 2)
    
    # Iteratively generate next seeds
    for (i in 1:rounds) {
        seeds = nextRound(seeds)
    }
    
    return(seeds)
}

#' Creates a seeding arrangement that is left skewed.
#' @author Eric Auster
#'
#' @param size is the number of seeds to generate. This needs
#' to be a power of two.
#'
#' @return a vector containing the seeds.
#'
left_skewed_seeding = function(size) {
    
    # Stop if not a power of two
    if (sum(as.numeric(intToBits(size))) != 1) {
        stop("Size must be a power of two")
    }
    
    # Special case when size is 2
    if (size == 2) {
        return(c(1, 2))
    }
    
    # Create seeds and left/right branches
    seeds = 1:size
    left_seeds = numeric(size / 2)
    right_seeds = numeric(size / 2)
    
    # Indexes for the left/right branches
    left_idx = 1
    right_idx = 1
    
    # Keep track of which branch will get the next seed
    left_turn = TRUE
    
    # For each iteration add the first and last seed to the
    # current branch
    for (i in 1:(size / 2)) {
        if (left_turn) {
            left_seeds[left_idx] = seeds[i]
            left_seeds[left_idx + 1] = seeds[(size + 1) - i]
            left_idx = left_idx + 2
            left_turn = FALSE
        } else {
            right_seeds[right_idx] = seeds[i]
            right_seeds[right_idx + 1] = seeds[(size + 1) - i]
            right_idx = right_idx + 2
            left_turn = TRUE
        }
    }
    
    # Combine branches
    c(left_seeds, right_seeds)
}

#' Creates a random seeding arrangement.
#' @author Eric Auster
#'
#' @param size is the number of seeds to generate. This needs
#' to be a power of two.
#'
#' @return a vector containing the seeds.
#'
random_seeding = function(size) {
    # Stop if not a power of two
    if (sum(as.numeric(intToBits(size))) != 1) {
        stop("Size must be a power of two")
    }
    
    return(sample(1:size, size))
}
```

### Simulation Functions

```{r}
#' Simulates a single game between two teams.
#' @author Jeffrey Chao, Phillip Dohm
#' 
#' @param teams vector containing the two teams to face-off.
#' @param matchups probability matrix.
#' 
#' @return winner of the game.
#' 
simGame <- function(teams, matchups) {
    team1 <- teams[1]
    team2 <- teams[2]
    matchup <- matchups[team1, team2]
    
    if (runif(1) < matchup) {
        return(team1)
    } else {
        return(team2)
    }
}

#' Simulates an entire round of a tournament.
#' @author Jeffrey Chao, Phillip Dohm
#' 
#' @param bracket is the bracket structure.
#' @param matchups is the probability matrix.
#' 
#' @return vector containing the winners of the round.
#' 
simRound <- function(bracket, matchups) {
    nGames <- length(bracket)/2
    outBracket <- c()
    for (game in 1:nGames) {
        teams <- bracket[(2*game - 1):(2*game)]
        winner <- simGame(teams, matchups)
        outBracket <- c(outBracket, winner)
    }
    
    return(outBracket)
}

#' Simulates an entire tournament given a bracket and probability matrix.
#' @author Jeffrey Chao, Phillip Dohm
#' 
#' @param bracket is the bracket structure.
#' @param matchups is the probability matrix.
#' 
#' @return list containing the tournment winner and vector that stores
#' how many wins each team has gotten.
#' 
simTournament <- function(bracket, matchups) {
    nTeams <- length(bracket)
    newBracket <- bracket
    nRounds <- log2(nTeams)
    
    results = c("Winner"=-1,"WinsPerTeam"=list(rep(0, ncol(matchups))))
    
    for (round in 1:nRounds) {
        #winsPrev = results["WinsPerTeam"]
        newBracket <- simRound(newBracket, matchups)
        for(i in newBracket){
            results$WinsPerTeam[i] = results$WinsPerTeam[i]+1
        }
    }
    
    results["Winner"] = newBracket
    return(results)
}
```

### Bayesian Functions

```{r}
#' Gets the win distribution for teams after a number of simulations.
#' @author Phillip Dohm
#' 
#' @param bracket is the tournament bracket structure.
#' @param matchups is the probability matrix.
#' @param nSim is the number of simulations.
#' 
#' @return is table containing the win distribution for each team.
#' 
getWinDistribution <- function(bracket, matchups, nSim=10000) {
    simResults <- replicate(nSim, simTournament(bracket, matchups), simplify='array')
    winners <- numeric(nSim)
    for(i in 1:nSim) winners[i] = simResults[,i]$Winner
    out <- data.frame(table(winners))
    colnames(out) <- c("teams", "freq")
    out$teams <- as.numeric(out$teams)
    return(out)
}

#' Gets the prior and posterior win distributions of an old and new bracket.
#' @author Phillip Dohm
#' 
#' @param oldBracket is the prior bracket to generate win distribution from.
#' @param newBracket is the posterior bracket to generate win distribution from.
#' @param matchups is the probability matrix.
#' @param nSim is the number of simulations.
#' 
#' @return table containing the prior and posterior win distributions.
#' 
getPriorAndPosteriorWins <- function(oldBracket, newBracket, matchups, nSim=10000) {
    prior <- getWinDistribution(oldBracket, matchups, nSim)
    posterior <- getWinDistribution(newBracket, matchups, nSim)
    
    out <- prior
    colnames(out) <- c("teams", "priorFreq")
    
    nTeams <- length(oldBracket)
    for (team in 1:nTeams) {
        if (!(any(newBracket == team))) {
            tempDF <- data.frame(t(c(team, 0)))
            colnames(tempDF) <- c("teams", "freq")
            posterior <- rbind(posterior, tempDF)
        }
    }
    
    posterior <- posterior[order(posterior$teams),]
    out$postFreq <- posterior$freq
    
    return(out)
}

#' Gets the expected number of wins for each team in a given bracket.
#' @author Phillip Dohm
#' 
#' @param bracket is the bracket structure.
#' @param matchups is the probability matrix.
#' @param nSim is the number of simulations.
#' 
#' @return table containing the expected number of wins for each team
#' and standard distribution.
#' 
getExpectedWins <- function(bracket, matchups, nSim=10000) {
    simResults <- replicate(nSim, simTournament(bracket, matchups), simplify='array')
    
    winsPerTeam <- c()
    for(i in 1:nSim) winsPerTeam = rbind(winsPerTeam, simResults[,i]$WinsPerTeam)
    expWins <- apply(winsPerTeam, MARGIN=2, FUN=mean)
    sdWins <- apply(winsPerTeam, MARGIN=2, FUN=sd)
    
    teams <- 1:ncol(matchups)
    out <- data.frame(teams, expWins, sdWins)
    out$teams <- as.numeric(out$teams)
    return(out)
}

#' Gets the prior and posterior expected wins of an old and new bracket.
#' @author Phillip Dohm
#' 
#' @param oldBracket is the prior bracket to generate expected wins from.
#' @param newBracket is the posterior bracket to generate expected wins from.
#' @param matchups is the probability matrix.
#' @param nSim is the number of simulations.
#' 
#' @return table containing the prior and posterior expected wins.
#' 
getPriorAndPosteriorExpectedWins <- function(oldBracket, newBracket, matchups, nSim=10000) {
    prior <- getExpectedWins(oldBracket, matchups, nSim)
    posterior <- getExpectedWins(newBracket, matchups, nSim)
    
    out <- prior
    colnames(out) <- c("teams", "priorExp", "priorSD")
    
    totTeams <- ncol(matchups)
    oldTeams <- length(oldBracket)
    newTeams <- length(newBracket)
    
    oldRounds <- log2(totTeams) - log2(oldTeams)
    newRounds <- log2(totTeams) - log2(newTeams)
    
    out$priorExp <- out$priorExp
    out$postExp <- posterior$expWins
    out$postSD <- posterior$sdWins
    
    for (team in 1:totTeams) {
        if (any(newBracket == team)) out$postExp[team] = out$postExp[team] + newRounds
        if (any(oldBracket == team)) out$priorExp[team] = out$priorExp[team] + oldRounds
    }
    
    return(out)
}
```

### Resampling Functions

```{r}
#' Generates bootstrap replicates.
#' @author Ziqin Xiong
#' 
#' @param x is a vector of team ranking or other measure of team power in different simulations.
#' @param B is number of replicates to generate.
#' @param estimator is the statistic we want, set as mean by default.
#' @param l is the length of bootstrap resample in each run.
#' 
#' @return list of bootstrap replicates, bias and standard error.
#' 
boot_replicate <- function(x, B = 5000, estimator = mean, l = length(x)){
    boots <- replicate(B, estimator(sample(x,l,replace=TRUE)))
    sd_b <- sd(boots)
    bias_b <- mean(boots - estimator(x))
    list(boot = boots, bias = bias_b, se = sd_b)
}

#' Generate jackknife replicates.
#' @author Ziqin Xiong
#' 
#' @param x is vector of team ranking or other measure of team power in different simulations.
#' @param estimator is the statistic we want, set as mean by default.
#' 
#' @return list of jackknife replicates, bias and standard error.
#' 
jack_replicate <- function(x, estimator = mean){
    n <- length(x)
    jack <- numeric(n)
    #perform jackknife
    for(i in 1:n)
        jack[i] <- estimator(x[-i])
    #bias using jackknife
    bias_j <- (n-1)*(mean(jack)-estimator(x))
    sumsq=sum((jack-mean(jack))^2)
    se_j <- sqrt((n-1)/n)*sqrt(sumsq)
    list(jack = jack,bias = bias_j, se = se_j)
}
```

-----
